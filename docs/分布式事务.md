
> åˆ†å¸ƒå¼äº‹åŠ¡åˆæ˜¯æ€æ ·å®ç°å‘¢ï¼Ÿæˆ‘è¿™ä¸ªåˆ†å¸ƒå¼æ¶ˆæ¯é˜Ÿåˆ—éœ€è¦å®ç°åˆ†å¸ƒå¼äº‹åŠ¡å—ï¼Ÿç”¨äºä»€ä¹ˆåœºæ™¯è¯·ä¸¾ä¾‹ã€‚ 

âº éå¸¸å¥½çš„é—®é¢˜ï¼è®©æˆ‘è¯¦ç»†è§£é‡Šåˆ†å¸ƒå¼äº‹åŠ¡åœ¨æ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„ä½œç”¨å’Œå®ç°ã€‚

  ---
  å…ˆå›ç­”ï¼šä½ çš„MQéœ€è¦åˆ†å¸ƒå¼äº‹åŠ¡å—ï¼Ÿ

  çŸ­ç­”æ¡ˆï¼šçœ‹åœºæ™¯ï¼Œä¸æ˜¯å¿…é¡»çš„

  ä¼˜å…ˆçº§æ’åºï¼š
  1. å‰¯æœ¬ä¸€è‡´æ€§ï¼ˆå¿…é¡»ï¼‰      â† ç”Ÿæ­»æ”¸å…³
  2. å¹‚ç­‰æ€§ï¼ˆæ¨èï¼‰          â† å®ç”¨ä»·å€¼é«˜
  3. åˆ†å¸ƒå¼äº‹åŠ¡ï¼ˆé«˜çº§ç‰¹æ€§ï¼‰   â† ç‰¹å®šåœºæ™¯éœ€è¦

  å»ºè®®ï¼š
  - å…ˆåšå‰¯æœ¬æœºåˆ¶
  - å†åšå¹‚ç­‰æ€§
  - æœ€åè€ƒè™‘åˆ†å¸ƒå¼äº‹åŠ¡ï¼ˆæˆ–è€…ä¸åšï¼‰

  ---
  ä»€ä¹ˆæ˜¯æ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„åˆ†å¸ƒå¼äº‹åŠ¡ï¼Ÿ

  å¸¸è§è¯¯è§£

  âŒ é”™è¯¯ç†è§£1ï¼š
  "åˆ†å¸ƒå¼äº‹åŠ¡ = å¤šä¸ªæœåŠ¡ä¹‹é—´çš„äº‹åŠ¡ï¼ˆSaga/TCCï¼‰"
  â†’ è¿™æ˜¯å¾®æœåŠ¡çš„åˆ†å¸ƒå¼äº‹åŠ¡ï¼Œä¸æ˜¯MQå†…éƒ¨çš„

  âŒ é”™è¯¯ç†è§£2ï¼š
  "åˆ†å¸ƒå¼äº‹åŠ¡ = ä¸¤é˜¶æ®µæäº¤ï¼ˆ2PCï¼‰"
  â†’ 2PCæ€§èƒ½å·®ï¼Œç°ä»£MQä¸ç”¨è¿™ä¸ª

  æ­£ç¡®ç†è§£

  æ¶ˆæ¯é˜Ÿåˆ—çš„åˆ†å¸ƒå¼äº‹åŠ¡ =
  ä¿è¯"ä¸€æ‰¹æ¶ˆæ¯"è¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥ï¼ˆåŸå­æ€§ï¼‰

  æ ¸å¿ƒåœºæ™¯ï¼š
  1. æ‰¹é‡å‘é€æ¶ˆæ¯ï¼ˆåŸå­æ€§ï¼‰
  2. æ¶ˆæ¯å‘é€ + æ•°æ®åº“æ“ä½œï¼ˆåŸå­æ€§ï¼‰
  3. æ¶ˆè´¹æ¶ˆæ¯ + å¤„ç† + å‘é€æ–°æ¶ˆæ¯ï¼ˆåŸå­æ€§ï¼‰

  ---
  åœºæ™¯1ï¼šæ‰¹é‡å‘é€æ¶ˆæ¯çš„åŸå­æ€§

  é—®é¢˜åœºæ™¯

  // ç”µå•†è®¢å•ç³»ç»Ÿ
  async fn create_order(order: Order) -> Result<()> {
      // éœ€è¦å‘é€å¤šæ¡æ¶ˆæ¯
      kafka.send("order-created", order.to_json()).await?;      // âœ“ æˆåŠŸ
      kafka.send("inventory-reserve", order.items).await?;       // âœ“ æˆåŠŸ
      kafka.send("payment-process", order.payment).await?;       // âœ— å¤±è´¥ï¼

      // é—®é¢˜ï¼š
      // - å‰ä¸¤æ¡æ¶ˆæ¯å·²ç»å‘é€æˆåŠŸäº†
      // - ä½†ç¬¬ä¸‰æ¡å¤±è´¥äº†
      // - ä¸‹æ¸¸æœåŠ¡ä¼šçœ‹åˆ°ä¸ä¸€è‡´çš„çŠ¶æ€ï¼š
      //   * è®¢å•åˆ›å»ºäº†
      //   * åº“å­˜æ‰£å‡äº†
      //   * ä½†æ²¡æœ‰æ”¯ä»˜æ¶ˆæ¯ï¼

      Ok(())
  }

  æ— äº‹åŠ¡çš„ç³Ÿç³•ç»“æœ

  æ—¶åˆ»T1: å‘é€"order-created" â†’ æˆåŠŸ
          è®¢å•æœåŠ¡æ”¶åˆ°ï¼Œåˆ›å»ºè®¢å•

  æ—¶åˆ»T2: å‘é€"inventory-reserve" â†’ æˆåŠŸ
          åº“å­˜æœåŠ¡æ”¶åˆ°ï¼Œæ‰£å‡åº“å­˜

  æ—¶åˆ»T3: å‘é€"payment-process" â†’ ç½‘ç»œè¶…æ—¶å¤±è´¥ï¼
          æ”¯ä»˜æœåŠ¡æ²¡æ”¶åˆ°

  æ—¶åˆ»T4: ç”¨æˆ·çœ‹åˆ°ï¼š
          âœ“ è®¢å•å·²åˆ›å»º
          âœ“ åº“å­˜å·²æ‰£å‡
          âœ— ä½†æ²¡æœ‰æ”¯ä»˜è®°å½•

  ç»“æœï¼šæ•°æ®ä¸ä¸€è‡´ï¼ŒæŸå¤±æƒ¨é‡ï¼

  Kafkaäº‹åŠ¡çš„è§£å†³æ–¹æ¡ˆ

  use rdkafka::producer::{FutureProducer, FutureRecord};

  async fn create_order_with_transaction(order: Order) -> Result<()> {
      let producer = FutureProducer::new(/* config */);

      // 1. å¼€å§‹äº‹åŠ¡
      producer.begin_transaction()?;

      let result = async {
          // 2. å‘é€æ¶ˆæ¯ï¼ˆæ ‡è®°ä¸ºäº‹åŠ¡æ€§çš„ï¼‰
          producer.send(
              FutureRecord::to("order-created")
                  .payload(&order.to_json())
                  .key(&order.id),
              Duration::from_secs(0)
          ).await?;

          producer.send(
              FutureRecord::to("inventory-reserve")
                  .payload(&order.items.to_json())
                  .key(&order.id),
              Duration::from_secs(0)
          ).await?;

          producer.send(
              FutureRecord::to("payment-process")
                  .payload(&order.payment.to_json())
                  .key(&order.id),
              Duration::from_secs(0)
          ).await?;

          Ok::<_, Error>(())
      }.await;

      // 3. æäº¤æˆ–å›æ»š
      match result {
          Ok(_) => {
              producer.commit_transaction(Duration::from_secs(5))?;
              println!("âœ“ All messages committed");
          }
          Err(e) => {
              producer.abort_transaction(Duration::from_secs(5))?;
              println!("âœ— Transaction aborted: {}", e);
          }
      }

      Ok(())
  }

  // æ•ˆæœï¼š
  // - ä¸‰æ¡æ¶ˆæ¯è¦ä¹ˆéƒ½å¯è§ï¼Œè¦ä¹ˆéƒ½ä¸å¯è§
  // - æ¶ˆè´¹è€…ä¸ä¼šçœ‹åˆ°"éƒ¨åˆ†æ¶ˆæ¯"

  ---
  åœºæ™¯2ï¼šæ•°æ®åº“ + æ¶ˆæ¯é˜Ÿåˆ—çš„åŸå­æ€§ï¼ˆæœ€å¸¸è§ï¼ï¼‰

  å…¸å‹é—®é¢˜ï¼šè½¬è´¦åœºæ™¯

  // é“¶è¡Œè½¬è´¦ç³»ç»Ÿ
  async fn transfer_money(from: u64, to: u64, amount: u64) -> Result<()> {
      let mut tx = db.begin_transaction().await?;

      // 1. æ•°æ®åº“æ“ä½œ
      tx.execute("UPDATE accounts SET balance = balance - ? WHERE id = ?",
                 (amount, from)).await?;
      tx.execute("UPDATE accounts SET balance = balance + ? WHERE id = ?",
                 (amount, to)).await?;

      tx.commit().await?;

      // 2. å‘é€æ¶ˆæ¯é€šçŸ¥
      kafka.send("transfer-completed", json!({
          "from": from,
          "to": to,
          "amount": amount
      })).await?;  // â† å¦‚æœè¿™é‡Œå¤±è´¥äº†æ€ä¹ˆåŠï¼Ÿ

      Ok(())
  }

  // é—®é¢˜ï¼š
  // - æ•°æ®åº“å·²æäº¤
  // - ä½†æ¶ˆæ¯å‘é€å¤±è´¥
  // - ä¸‹æ¸¸æœåŠ¡ä¸çŸ¥é“è½¬è´¦å·²å®Œæˆ
  // - æˆ–è€…ç›¸åï¼šæ¶ˆæ¯å‘é€æˆåŠŸï¼Œä½†æ•°æ®åº“å›æ»šäº†

  è§£å†³æ–¹æ¡ˆAï¼šæœ¬åœ°æ¶ˆæ¯è¡¨ï¼ˆæœ€å¸¸ç”¨ï¼‰

  // æ•°æ®åº“schema
  // CREATE TABLE outbox (
  //     id BIGINT PRIMARY KEY,
  //     topic VARCHAR(255),
  //     payload TEXT,
  //     created_at TIMESTAMP,
  //     sent BOOLEAN DEFAULT FALSE
  // );

  async fn transfer_with_outbox(from: u64, to: u64, amount: u64) -> Result<()> {
      let mut tx = db.begin_transaction().await?;

      // 1. ä¸šåŠ¡æ“ä½œ
      tx.execute("UPDATE accounts SET balance = balance - ? WHERE id = ?",
                 (amount, from)).await?;
      tx.execute("UPDATE accounts SET balance = balance + ? WHERE id = ?",
                 (amount, to)).await?;

      // 2. åœ¨åŒä¸€ä¸ªäº‹åŠ¡ä¸­å†™å…¥outboxè¡¨
      let msg = json!({
          "from": from,
          "to": to,
          "amount": amount
      });
      tx.execute("INSERT INTO outbox (topic, payload, created_at) VALUES (?, ?, NOW())",
                 ("transfer-completed", msg.to_string())).await?;

      // 3. æäº¤äº‹åŠ¡ï¼ˆåŸå­æ€§ï¼‰
      tx.commit().await?;

      Ok(())
  }

  // åå°ä»»åŠ¡ï¼šå®šæ—¶æ‰«æoutboxè¡¨å¹¶å‘é€æ¶ˆæ¯
  async fn outbox_publisher_loop(db: Database, kafka: KafkaProducer) {
      loop {
          tokio::time::sleep(Duration::from_millis(100)).await;

          // æŸ¥è¯¢æœªå‘é€çš„æ¶ˆæ¯
          let pending = db.query("SELECT * FROM outbox WHERE sent = FALSE LIMIT 100").await;

          for msg in pending {
              // å‘é€åˆ°Kafka
              match kafka.send(msg.topic, msg.payload).await {
                  Ok(_) => {
                      // æ ‡è®°ä¸ºå·²å‘é€
                      db.execute("UPDATE outbox SET sent = TRUE WHERE id = ?", msg.id).await;
                  }
                  Err(e) => {
                      eprintln!("Failed to send message: {}", e);
                      // ä¼šåœ¨ä¸‹æ¬¡å¾ªç¯é‡è¯•
                  }
              }
          }
      }
  }

  // ä¼˜ç‚¹ï¼š
  // âœ“ å®ç°ç®€å•
  // âœ“ ä¿è¯æœ€ç»ˆä¸€è‡´æ€§
  // âœ“ æ•°æ®åº“å’Œæ¶ˆæ¯é˜Ÿåˆ—è§£è€¦

  // ç¼ºç‚¹ï¼š
  // âœ— æœ‰å»¶è¿Ÿï¼ˆå¼‚æ­¥å‘é€ï¼‰
  // âœ— éœ€è¦é¢å¤–çš„è¡¨å’Œåå°ä»»åŠ¡
  // âœ— å¯èƒ½é‡å¤å‘é€ï¼ˆéœ€è¦æ¶ˆè´¹è€…å¹‚ç­‰ï¼‰

  è§£å†³æ–¹æ¡ˆBï¼šKafkaäº‹åŠ¡ï¼ˆå®Œç¾ä½†å¤æ‚ï¼‰

  async fn transfer_with_kafka_transaction(
      from: u64,
      to: u64,
      amount: u64
  ) -> Result<()> {
      // Kafkaä½œä¸ºäº‹åŠ¡åè°ƒå™¨
      let producer = TransactionalProducer::new("transfer-txn-producer");

      producer.init_transactions()?;
      producer.begin_transaction()?;

      let result = async {
          // 1. å‘é€"prepare"æ¶ˆæ¯ï¼ˆå¸¦äº‹åŠ¡æ ‡è®°ï¼‰
          producer.send_in_transaction("db-operations", json!({
              "type": "prepare",
              "from": from,
              "to": to,
              "amount": amount
          })).await?;

          // 2. æ‰§è¡Œæ•°æ®åº“æ“ä½œ
          let mut tx = db.begin_transaction().await?;
          tx.execute("UPDATE accounts SET balance = balance - ? WHERE id = ?",
                     (amount, from)).await?;
          tx.execute("UPDATE accounts SET balance = balance + ? WHERE id = ?",
                     (amount, to)).await?;
          tx.commit().await?;

          // 3. å‘é€"commit"æ¶ˆæ¯
          producer.send_in_transaction("transfer-completed", json!({
              "from": from,
              "to": to,
              "amount": amount
          })).await?;

          Ok::<_, Error>(())
      }.await;

      match result {
          Ok(_) => producer.commit_transaction()?,
          Err(e) => {
              producer.abort_transaction()?;
              // éœ€è¦è¡¥å¿é€»è¾‘å›æ»šæ•°æ®åº“
          }
      }

      Ok(())
  }

  // é—®é¢˜ï¼š
  // - Kafkaåªèƒ½ä¿è¯æ¶ˆæ¯çš„äº‹åŠ¡æ€§
  // - ä¸èƒ½ç›´æ¥å›æ»šæ•°æ®åº“
  // - è¿˜æ˜¯éœ€è¦è¡¥å¿æœºåˆ¶

  ---
  åœºæ™¯3ï¼šExactly-Onceè¯­ä¹‰ï¼ˆæ¶ˆè´¹ + å¤„ç† + å‘é€ï¼‰

  å…¸å‹åœºæ™¯ï¼šæµå¤„ç†

  // åœºæ™¯ï¼šå®æ—¶é£æ§ç³»ç»Ÿ
  // æ¶ˆè´¹è®¢å• â†’ é£é™©è¯„ä¼° â†’ å‘é€ç»“æœ

  async fn risk_assessment_without_transaction() -> Result<()> {
      let consumer = KafkaConsumer::new();
      let producer = KafkaProducer::new();

      loop {
          let msg = consumer.poll().await?;
          let order: Order = serde_json::from_slice(&msg.payload)?;

          // 1. é£é™©è¯„ä¼°
          let risk_score = calculate_risk(&order).await;

          // 2. å‘é€ç»“æœ
          producer.send("risk-results", json!({
              "order_id": order.id,
              "score": risk_score
          })).await?;  // â† å¦‚æœè¿™é‡Œå¤±è´¥äº†ï¼Ÿ

          // 3. æäº¤offset
          consumer.commit_offset(msg.offset).await?;  // â† æˆ–è€…è¿™é‡Œå¤±è´¥äº†ï¼Ÿ
      }
  }

  // é—®é¢˜1ï¼šæ¶ˆæ¯é‡å¤å¤„ç†
  // - å‘é€æˆåŠŸï¼Œä½†commit offsetå¤±è´¥
  // - é‡å¯åé‡æ–°æ¶ˆè´¹è¯¥æ¶ˆæ¯
  // - å¯¼è‡´é£é™©è¯„åˆ†å‘é€äº†ä¸¤æ¬¡

  // é—®é¢˜2ï¼šæ¶ˆæ¯ä¸¢å¤±
  // - commit offsetæˆåŠŸï¼Œä½†å‘é€å¤±è´¥
  // - è¯¥æ¶ˆæ¯ä¸ä¼šå†å¤„ç†
  // - å¯¼è‡´é£é™©è¯„åˆ†ä¸¢å¤±

  Kafkaäº‹åŠ¡çš„Exactly-Onceè§£å†³æ–¹æ¡ˆ

  async fn risk_assessment_with_transaction() -> Result<()> {
      let consumer = KafkaConsumer::new();
      let producer = TransactionalProducer::new("risk-processor");

      producer.init_transactions()?;

      loop {
          let msg = consumer.poll().await?;
          let order: Order = serde_json::from_slice(&msg.payload)?;

          // å¼€å§‹äº‹åŠ¡
          producer.begin_transaction()?;

          let result = async {
              // 1. é£é™©è¯„ä¼°
              let risk_score = calculate_risk(&order).await;

              // 2. å‘é€ç»“æœï¼ˆåœ¨äº‹åŠ¡ä¸­ï¼‰
              producer.send_in_transaction("risk-results", json!({
                  "order_id": order.id,
                  "score": risk_score
              })).await?;

              // 3. æäº¤offsetï¼ˆä¹Ÿåœ¨äº‹åŠ¡ä¸­ï¼ï¼‰â­
              producer.send_offsets_to_transaction(
                  &consumer.get_consumer_group_metadata(),
                  Duration::from_secs(5)
              )?;

              Ok::<_, Error>(())
          }.await;

          match result {
              Ok(_) => producer.commit_transaction()?,
              Err(e) => producer.abort_transaction()?,
          }
      }
  }

  // æ•ˆæœï¼š
  // âœ“ "æ¶ˆè´¹ + å¤„ç† + å‘é€ + æäº¤offset" æ˜¯åŸå­çš„
  // âœ“ è¦ä¹ˆéƒ½æˆåŠŸï¼Œè¦ä¹ˆéƒ½å¤±è´¥
  // âœ“ å®ç°Exactly-Onceè¯­ä¹‰

  ---
  Kafkaäº‹åŠ¡çš„å®ç°åŸç†ï¼ˆç®€åŒ–ç‰ˆï¼‰

  æ ¸å¿ƒæ¦‚å¿µ

  // 1. Transaction Coordinatorï¼ˆäº‹åŠ¡åè°ƒå™¨ï¼‰
  struct TransactionCoordinator {
      // ç®¡ç†æ‰€æœ‰äº‹åŠ¡çš„çŠ¶æ€
      transactions: DashMap<String, TransactionState>,
  }

  #[derive(Debug)]
  enum TransactionState {
      Empty,                    // åˆå§‹çŠ¶æ€
      Ongoing,                  // æ­£åœ¨è¿›è¡Œ
      PrepareCommit,            // å‡†å¤‡æäº¤
      PrepareAbort,             // å‡†å¤‡å›æ»š
      CompleteCommit,           // å·²æäº¤
      CompleteAbort,            // å·²å›æ»š
  }

  // 2. Transaction Logï¼ˆäº‹åŠ¡æ—¥å¿—ï¼‰
  // æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„Kafka Topicï¼š__transaction_state
  // æŒä¹…åŒ–æ‰€æœ‰äº‹åŠ¡çš„çŠ¶æ€å˜æ›´

  // 3. Control Messageï¼ˆæ§åˆ¶æ¶ˆæ¯ï¼‰
  enum ControlMessage {
      Commit(TransactionId),    // æ ‡è®°äº‹åŠ¡å·²æäº¤
      Abort(TransactionId),     // æ ‡è®°äº‹åŠ¡å·²å›æ»š
  }

  äº‹åŠ¡æ‰§è¡Œæµç¨‹

  // å®Œæ•´æµç¨‹ç¤ºä¾‹
  async fn kafka_transaction_flow() -> Result<()> {
      let producer = TransactionalProducer::new("my-txn-id");

      // === é˜¶æ®µ1: åˆå§‹åŒ– ===
      producer.init_transactions()?;
      // å†…éƒ¨ï¼šå‘Transaction Coordinatoræ³¨å†Œ
      // Coordinatoråœ¨__transaction_stateä¸­è®°å½•ï¼š
      // my-txn-id -> Empty

      // === é˜¶æ®µ2: å¼€å§‹äº‹åŠ¡ ===
      producer.begin_transaction()?;
      // Coordinatoræ›´æ–°çŠ¶æ€ï¼š
      // my-txn-id -> Ongoing

      // === é˜¶æ®µ3: å‘é€æ¶ˆæ¯ ===
      producer.send("topic1", "msg1").await?;
      producer.send("topic2", "msg2").await?;
      // æ¶ˆæ¯å†™å…¥å¯¹åº”çš„åˆ†åŒºï¼Œä½†å¸¦æœ‰äº‹åŠ¡æ ‡è®°ï¼š
      // [msg1, txn=my-txn-id, control=pending]
      // [msg2, txn=my-txn-id, control=pending]

      // æ¶ˆè´¹è€…è¯»å–æ—¶ï¼š
      // - READ_UNCOMMITTED: èƒ½çœ‹åˆ°è¿™äº›æ¶ˆæ¯
      // - READ_COMMITTED: çœ‹ä¸åˆ°ï¼ˆç­‰å¾…äº‹åŠ¡æäº¤ï¼‰

      // === é˜¶æ®µ4: å‡†å¤‡æäº¤ ===
      producer.commit_transaction()?;
      // 4.1 Coordinatorè®°å½•çŠ¶æ€ï¼š
      //     my-txn-id -> PrepareCommit

      // 4.2 Coordinatorå‘æ‰€æœ‰æ¶‰åŠçš„åˆ†åŒºå‘é€Control Messageï¼š
      //     topic1-partition0: COMMIT(my-txn-id)
      //     topic2-partition1: COMMIT(my-txn-id)

      // 4.3 ç­‰å¾…æ‰€æœ‰åˆ†åŒºç¡®è®¤

      // 4.4 Coordinatoræ›´æ–°æœ€ç»ˆçŠ¶æ€ï¼š
      //     my-txn-id -> CompleteCommit

      // === é˜¶æ®µ5: æ¶ˆè´¹è€…å¯è§ ===
      // READ_COMMITTEDçš„æ¶ˆè´¹è€…ç°åœ¨èƒ½çœ‹åˆ°msg1å’Œmsg2äº†

      Ok(())
  }

  å…³é”®æ•°æ®ç»“æ„

  // åˆ†åŒºä¸­çš„æ¶ˆæ¯æ ¼å¼
  struct TransactionalRecord {
      offset: u64,
      key: Vec<u8>,
      value: Vec<u8>,

      // äº‹åŠ¡ç›¸å…³å­—æ®µ
      producer_id: i64,           // ç”Ÿäº§è€…IDï¼ˆå”¯ä¸€æ ‡è¯†ï¼‰
      producer_epoch: i16,        // ç”Ÿäº§è€…çºªå…ƒï¼ˆé˜²æ­¢åƒµå°¸å®ä¾‹ï¼‰
      sequence: i32,              // æ¶ˆæ¯åºåˆ—å·ï¼ˆå¹‚ç­‰æ€§ï¼‰
      is_transactional: bool,     // æ˜¯å¦æ˜¯äº‹åŠ¡æ¶ˆæ¯

      // å¦‚æœæ˜¯æ§åˆ¶æ¶ˆæ¯
      is_control: bool,           // æ˜¯å¦æ˜¯æ§åˆ¶æ¶ˆæ¯
      control_type: ControlType,  // COMMIT or ABORT
  }

  // LSO: Last Stable Offsetï¼ˆæœ€åç¨³å®šåç§»é‡ï¼‰
  struct Partition {
      leo: u64,  // Log End Offset
      hw: u64,   // High Watermark
      lso: u64,  // Last Stable Offset â­

      // lso = ç¬¬ä¸€ä¸ªæœªå®Œæˆäº‹åŠ¡çš„èµ·å§‹offset
      // æ¶ˆè´¹è€…åªèƒ½è¯»åˆ° lso ä¹‹å‰çš„æ¶ˆæ¯
      ongoing_transactions: BTreeMap<u64, TransactionId>,
  }

  impl Partition {
      fn update_lso(&mut self) {
          // LSO = æœ€æ—©çš„æœªæäº¤äº‹åŠ¡çš„ç¬¬ä¸€æ¡æ¶ˆæ¯çš„offset
          self.lso = self.ongoing_transactions
              .keys()
              .next()
              .copied()
              .unwrap_or(self.hw);
      }

      fn consumer_can_read_until(&self, isolation_level: IsolationLevel) -> u64 {
          match isolation_level {
              IsolationLevel::ReadUncommitted => self.hw,
              IsolationLevel::ReadCommitted => self.lso,  // â­ å…³é”®
          }
      }
  }

  ---
  ä½ çš„CrabMQéœ€è¦å®ç°å—ï¼Ÿ

  åœºæ™¯åˆ¤æ–­

  éœ€è¦å®ç°äº‹åŠ¡çš„åœºæ™¯ï¼š

  1. é‡‘èç³»ç»Ÿï¼ˆâ˜…â˜…â˜…â˜…â˜…ï¼‰
     - æ”¯ä»˜ã€è½¬è´¦ã€äº¤æ˜“
     - ä¸¥æ ¼çš„ä¸€è‡´æ€§è¦æ±‚
     - ä¸èƒ½æœ‰é‡å¤æˆ–ä¸¢å¤±

  2. è®¢å•ç³»ç»Ÿï¼ˆâ˜…â˜…â˜…â˜…ï¼‰
     - è®¢å•åˆ›å»º + åº“å­˜ + æ”¯ä»˜
     - éœ€è¦åŸå­æ€§

  3. æµå¤„ç†ï¼ˆâ˜…â˜…â˜…â˜…ï¼‰
     - Exactly-Onceè¯­ä¹‰
     - Kafka Streamsçš„æ ¸å¿ƒä¾èµ–

  4. å®¡è®¡æ—¥å¿—ï¼ˆâ˜…â˜…â˜…â˜…ï¼‰
     - éœ€è¦ä¿è¯æ¶ˆæ¯ä¸é‡ä¸æ¼

  ä¸éœ€è¦äº‹åŠ¡çš„åœºæ™¯ï¼š

  1. ç›‘æ§æ—¥å¿—ï¼ˆâ˜…ï¼‰
     - å°‘é‡ä¸¢å¤±å¯æ¥å—
     - æ€§èƒ½ä¼˜å…ˆ

  2. ç”¨æˆ·è¡Œä¸ºè¿½è¸ªï¼ˆâ˜…â˜…ï¼‰
     - æœ€ç»ˆä¸€è‡´æ€§å³å¯
     - å¯ä»¥å®¹å¿é‡å¤

  3. ç®€å•çš„å¼‚æ­¥é€šçŸ¥ï¼ˆâ˜…â˜…ï¼‰
     - å‘é€çŸ­ä¿¡ã€é‚®ä»¶
     - å¹‚ç­‰æ“ä½œ

  4. ä½ä»·å€¼æ•°æ®ï¼ˆâ˜…ï¼‰
     - ä¸´æ—¶æ•°æ®ã€ç¼“å­˜å¤±æ•ˆé€šçŸ¥

  æˆ‘çš„å»ºè®®ï¼šåˆ†é˜¶æ®µè€ƒè™‘

  é˜¶æ®µ1ï¼šå¹‚ç­‰æ€§ï¼ˆä¼˜å…ˆåšï¼‰

  // æ¯”å®Œæ•´äº‹åŠ¡ç®€å•å¾ˆå¤šï¼Œä½†è§£å†³80%çš„é—®é¢˜

  struct IdempotentProducer {
      producer_id: u64,
      sequence: Arc<AtomicU64>,

      // è®°å½•å·²å‘é€çš„æ¶ˆæ¯ï¼ˆç”¨äºå»é‡ï¼‰
      sent_messages: Arc<DashMap<(String, u64), u64>>,  // (topic, seq) -> offset
  }

  impl IdempotentProducer {
      async fn send_idempotent(&self, topic: &str, msg: Message) -> Result<u64> {
          // 1. ç”Ÿæˆåºåˆ—å·
          let seq = self.sequence.fetch_add(1, Ordering::SeqCst);

          // 2. æ£€æŸ¥æ˜¯å¦å·²å‘é€
          if let Some(offset) = self.sent_messages.get(&(topic.to_string(), seq)) {
              return Ok(*offset);  // å¹‚ç­‰ï¼šè¿”å›å·²å­˜åœ¨çš„offset
          }

          // 3. å‘é€æ¶ˆæ¯
          let offset = self.send_with_sequence(topic, msg, seq).await?;

          // 4. è®°å½•
          self.sent_messages.insert((topic.to_string(), seq), offset);

          Ok(offset)
      }
  }

  // ä¼˜ç‚¹ï¼š
  // âœ“ å®ç°ç®€å•ï¼ˆ1-2å‘¨ï¼‰
  // âœ“ è§£å†³é‡å¤å‘é€é—®é¢˜
  // âœ“ ä¸å½±å“æ€§èƒ½

  // ç¼ºç‚¹ï¼š
  // âœ— ä¸ä¿è¯åŸå­æ€§ï¼ˆæ‰¹é‡æ¶ˆæ¯å¯èƒ½éƒ¨åˆ†æˆåŠŸï¼‰
  // âœ— ä¸æ”¯æŒExactly-Once

  é˜¶æ®µ2ï¼šæœ¬åœ°æ¶ˆæ¯è¡¨ï¼ˆä¸­ç­‰å¤æ‚åº¦ï¼‰

  // è§£å†³"æ•°æ®åº“ + MQ"çš„ä¸€è‡´æ€§é—®é¢˜

  // å·¥ä½œé‡ï¼š2-3å‘¨
  // æ”¶ç›Šï¼šå¾ˆé«˜ï¼ˆè¿™æ˜¯æœ€å¸¸è§çš„åœºæ™¯ï¼‰
  // éš¾åº¦ï¼šä¸­ç­‰

  // ä¹‹å‰å±•ç¤ºè¿‡å®ç°ï¼Œä¸å†é‡å¤

  é˜¶æ®µ3ï¼šå®Œæ•´äº‹åŠ¡ï¼ˆé«˜çº§ç‰¹æ€§ï¼‰

  // å®ç°Kafkaé£æ ¼çš„äº‹åŠ¡

  // å·¥ä½œé‡ï¼š2-3ä¸ªæœˆ
  // éš¾åº¦ï¼šâ˜…â˜…â˜…â˜…â˜… (9/10)

  // éœ€è¦å®ç°ï¼š
  // 1. Transaction Coordinatorï¼ˆäº‹åŠ¡åè°ƒå™¨ï¼‰
  // 2. äº‹åŠ¡æ—¥å¿—ï¼ˆTransaction Logï¼‰
  // 3. æ§åˆ¶æ¶ˆæ¯ï¼ˆControl Messagesï¼‰
  // 4. LSOæœºåˆ¶ï¼ˆLast Stable Offsetï¼‰
  // 5. Epochç®¡ç†ï¼ˆé˜²æ­¢åƒµå°¸ç”Ÿäº§è€…ï¼‰
  // 6. æ¶ˆè´¹è€…çš„READ_COMMITTEDæ¨¡å¼

  // å»ºè®®ï¼šé™¤éæœ‰æ˜ç¡®éœ€æ±‚ï¼Œå¦åˆ™ä¸åš

  ---
  å®ç°éš¾åº¦å¯¹æ¯”

  åŠŸèƒ½              éš¾åº¦    å·¥ä½œé‡    æ”¶ç›Š    ç”Ÿäº§å¿…éœ€
  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  å‰¯æœ¬ä¸€è‡´æ€§        9/10   3-6æœˆ    â˜…â˜…â˜…â˜…â˜…   å¿…é¡»
  å¹‚ç­‰æ€§           5/10   1-2å‘¨    â˜…â˜…â˜…â˜…    æ¨è
  æœ¬åœ°æ¶ˆæ¯è¡¨        6/10   2-3å‘¨    â˜…â˜…â˜…â˜…    æ¨è
  å®Œæ•´äº‹åŠ¡          9/10   2-3æœˆ    â˜…â˜…â˜…     ç‰¹å®šåœºæ™¯

  ---
  æ€»ç»“å’Œå»ºè®®

  1. ä½ çš„CrabMQç°åœ¨åº”è¯¥åšä»€ä¹ˆï¼Ÿ

  ä¼˜å…ˆçº§æ’åºï¼š
  1ï¸âƒ£ å‰¯æœ¬æœºåˆ¶ï¼ˆå¿…é¡»ï¼‰
     â†’ æ•°æ®å¯é æ€§çš„åŸºç¡€

  2ï¸âƒ£ å¹‚ç­‰æ€§ï¼ˆæ¨èï¼‰
     â†’ æ€§ä»·æ¯”æœ€é«˜ï¼Œè§£å†³é‡å¤é—®é¢˜

  3ï¸âƒ£ æœ¬åœ°æ¶ˆæ¯è¡¨ç¤ºä¾‹ï¼ˆå¯é€‰ï¼‰
     â†’ å¦‚æœä½ æƒ³å±•ç¤º"DB+MQ"åœºæ™¯

  4ï¸âƒ£ å®Œæ•´äº‹åŠ¡ï¼ˆæš‚ä¸åšï¼‰
     â†’ æŠ•å…¥äº§å‡ºæ¯”ä¸é«˜

  2. é¢è¯•æ—¶æ€ä¹ˆè¯´ï¼Ÿ

  æ–¹æ¡ˆAï¼šå·²å®ç°å¹‚ç­‰æ€§
  "æˆ‘å®ç°äº†å¹‚ç­‰æ€§æœºåˆ¶ï¼Œé€šè¿‡producer_idå’Œsequenceä¿è¯æ¶ˆæ¯ä¸é‡å¤å‘é€ï¼Œ
  è¿™è§£å†³äº†å¤§éƒ¨åˆ†åœºæ™¯çš„é—®é¢˜ã€‚å®Œæ•´çš„äº‹åŠ¡æœºåˆ¶æŠ•å…¥äº§å‡ºæ¯”ä¸é«˜ï¼Œæš‚æœªå®ç°ã€‚"

  æ–¹æ¡ˆBï¼šè®¡åˆ’å®ç°æœ¬åœ°æ¶ˆæ¯è¡¨
  "å¯¹äºæ•°æ®åº“å’Œæ¶ˆæ¯é˜Ÿåˆ—çš„ä¸€è‡´æ€§é—®é¢˜ï¼Œæˆ‘è®¾è®¡äº†åŸºäºæœ¬åœ°æ¶ˆæ¯è¡¨çš„æ–¹æ¡ˆï¼Œ
  é€šè¿‡Outboxæ¨¡å¼ä¿è¯æœ€ç»ˆä¸€è‡´æ€§ï¼Œè¿™æ˜¯å·¥ä¸šç•Œæœ€å¸¸ç”¨çš„å®è·µã€‚"

  æ–¹æ¡ˆCï¼šäº†è§£ä½†ä¸å®ç°
  "æˆ‘æ·±å…¥ç ”ç©¶äº†Kafkaçš„äº‹åŠ¡æœºåˆ¶ï¼ŒåŒ…æ‹¬Transaction Coordinatorã€
  æ§åˆ¶æ¶ˆæ¯ã€LSOç­‰æ ¸å¿ƒæ¦‚å¿µï¼Œä½†è€ƒè™‘åˆ°å¤æ‚åº¦ï¼ŒCrabMQæš‚æœªå®ç°ã€‚"

  3. ä»€ä¹ˆæ—¶å€™éœ€è¦å®Œæ•´äº‹åŠ¡ï¼Ÿ

  åªæœ‰ä»¥ä¸‹åœºæ™¯æ‰çœŸæ­£éœ€è¦ï¼š

  âœ“ é‡‘èç³»ç»Ÿçš„Exactly-Once
  âœ“ å¤æ‚çš„æµå¤„ç†ï¼ˆKafka Streamsé£æ ¼ï¼‰
  âœ“ ä¸¥æ ¼çš„åŸå­æ€§è¦æ±‚ï¼ˆæ‰¹é‡æ¶ˆæ¯ï¼‰

  å¯¹äºï¼š
  - å­¦ä¹ é¡¹ç›®
  - å°è§„æ¨¡åº”ç”¨
  - ä¸€èˆ¬çš„å¼‚æ­¥é€šä¿¡

  â†’ å¹‚ç­‰æ€§ + æœ¬åœ°æ¶ˆæ¯è¡¨ å·²ç»è¶³å¤Ÿ

  4. æœ€ç»ˆå»ºè®®

  å½“å‰é˜¶æ®µï¼ˆCrabMQï¼‰ï¼š
  1. ä¸“æ³¨äºå‰¯æœ¬æœºåˆ¶ï¼ˆæ ¸å¿ƒï¼‰
  2. åŠ ä¸Šå¹‚ç­‰æ€§ï¼ˆæ€§ä»·æ¯”é«˜ï¼‰
  3. æ–‡æ¡£ä¸­è¯´æ˜äº‹åŠ¡çš„è®¾è®¡æ€è·¯ï¼ˆå±•ç¤ºç†è§£ï¼‰
  4. ä¸å®ç°å®Œæ•´äº‹åŠ¡ï¼ˆé™¤éæœ‰ç‰¹å®šéœ€æ±‚ï¼‰

  ç†ç”±ï¼š
  - åˆ†å¸ƒå¼äº‹åŠ¡å¾ˆå¤æ‚ï¼ˆ2-3ä¸ªæœˆï¼‰
  - ä½†å¤§å¤šæ•°åœºæ™¯ä¸éœ€è¦
  - æŠŠæ—¶é—´èŠ±åœ¨å‰¯æœ¬æœºåˆ¶ä¸Šæ›´å€¼å¾—

  ---

  ## åˆ†å¸ƒå¼äº‹åŠ¡å®ç°çš„æŠ€æœ¯éš¾ç‚¹ä¸ç»†èŠ‚

  ### éš¾ç‚¹1ï¼šåˆ†å¸ƒå¼ç¯å¢ƒä¸‹çš„çŠ¶æ€ä¸€è‡´æ€§

  é—®é¢˜ï¼šTransaction Coordinatorå´©æºƒæ€ä¹ˆåŠï¼Ÿ

  åœºæ™¯ï¼š
  1. Producerå‘é€äº†äº‹åŠ¡æ¶ˆæ¯åˆ°å¤šä¸ªåˆ†åŒº
  2. Coordinatorè®°å½•äº†äº‹åŠ¡çŠ¶æ€ä¸º"Ongoing"
  3. Producerå‘é€commitè¯·æ±‚
  4. Coordinatoråœ¨å‘é€Control Messageåˆ°åˆ†åŒº1åå´©æºƒ
  5. åˆ†åŒº1æœ‰COMMITæ ‡è®°ï¼Œä½†åˆ†åŒº2-5æ²¡æœ‰

  ç»“æœï¼š
  - æ¶ˆè´¹è€…ä»åˆ†åŒº1èƒ½çœ‹åˆ°äº‹åŠ¡æ¶ˆæ¯ï¼ˆå·²æäº¤ï¼‰
  - æ¶ˆè´¹è€…ä»åˆ†åŒº2-5çœ‹ä¸åˆ°ï¼ˆæœªæäº¤ï¼‰
  - æ•°æ®ä¸ä¸€è‡´ï¼

  è§£å†³æ–¹æ¡ˆï¼šäº‹åŠ¡æ—¥å¿—æŒä¹…åŒ– + æ¢å¤æœºåˆ¶

  ```rust
  // Transaction Coordinatorçš„æŒä¹…åŒ–æœºåˆ¶
  struct TransactionCoordinator {
      // äº‹åŠ¡çŠ¶æ€åœ¨å†…å­˜ä¸­
      transactions: DashMap<TxnId, TransactionMetadata>,

      // æŒä¹…åŒ–åˆ°ç‰¹æ®ŠTopic: __transaction_state
      txn_log: TransactionLog,
  }

  #[derive(Debug, Clone)]
  struct TransactionMetadata {
      txn_id: String,
      producer_id: i64,
      producer_epoch: i16,
      state: TransactionState,

      // â­ å…³é”®ï¼šè®°å½•äº‹åŠ¡æ¶‰åŠçš„æ‰€æœ‰åˆ†åŒº
      partitions: HashSet<TopicPartition>,

      // è¶…æ—¶æ—¶é—´
      timeout_ms: u64,
      last_update_time: Instant,
  }

  // å´©æºƒæ¢å¤æµç¨‹
  impl TransactionCoordinator {
      async fn recover_from_crash(&mut self) -> Result<()> {
          println!("ğŸ”„ Recovering transaction state from log...");

          // 1. ä»__transaction_stateè¯»å–æ‰€æœ‰äº‹åŠ¡
          let transactions = self.txn_log.read_all().await?;

          for txn in transactions {
              match txn.state {
                  TransactionState::Ongoing => {
                      // æ£€æŸ¥è¶…æ—¶
                      if txn.is_timeout() {
                          // è¶…æ—¶çš„äº‹åŠ¡ï¼Œå‘é€ABORT
                          self.abort_transaction(&txn).await?;
                      } else {
                          // æœªè¶…æ—¶ï¼Œæ¢å¤åˆ°å†…å­˜
                          self.transactions.insert(txn.txn_id.clone(), txn);
                      }
                  }

                  TransactionState::PrepareCommit => {
                      // â­ å…³é”®ï¼šå·²ç»å¼€å§‹æäº¤äº†ï¼Œå¿…é¡»å®Œæˆï¼
                      // é‡æ–°å‘æ‰€æœ‰åˆ†åŒºå‘é€COMMIT
                      self.complete_commit(&txn).await?;
                  }

                  TransactionState::PrepareAbort => {
                      // åŒç†ï¼Œå®Œæˆå›æ»š
                      self.complete_abort(&txn).await?;
                  }

                  TransactionState::CompleteCommit |
                  TransactionState::CompleteAbort => {
                      // å·²å®Œæˆï¼Œå¯ä»¥æ¸…ç†
                      self.txn_log.remove(&txn.txn_id).await?;
                  }

                  _ => {}
              }
          }

          println!("âœ“ Recovered {} transactions", self.transactions.len());
          Ok(())
      }

      // å®Œæˆæäº¤ï¼ˆå¹‚ç­‰æ“ä½œï¼‰
      async fn complete_commit(&self, txn: &TransactionMetadata) -> Result<()> {
          let control_msg = ControlMessage::Commit(txn.txn_id.clone());

          // å‘æ‰€æœ‰åˆ†åŒºå‘é€COMMITæ§åˆ¶æ¶ˆæ¯
          for partition in &txn.partitions {
              // â­ å¿…é¡»æ˜¯å¹‚ç­‰çš„ï¼šé‡å¤å‘é€ä¸ä¼šæœ‰å‰¯ä½œç”¨
              self.send_control_message(partition, control_msg.clone()).await?;
          }

          // æ›´æ–°çŠ¶æ€ä¸ºCompleteCommit
          self.update_txn_state(&txn.txn_id, TransactionState::CompleteCommit).await?;

          Ok(())
      }
  }
  ```

  å…³é”®ç‚¹ï¼š
  1. **PrepareCommitæ˜¯å†³ç­–ç‚¹**ï¼šä¸€æ—¦è¿›å…¥è¿™ä¸ªçŠ¶æ€ï¼Œå¿…é¡»å®Œæˆæäº¤ï¼ˆå³ä½¿é‡å¯ï¼‰
  2. **å¹‚ç­‰æ€§**ï¼šControl Messageå¿…é¡»å¯ä»¥é‡å¤å‘é€
  3. **è¶…æ—¶å¤„ç†**ï¼šé•¿æ—¶é—´Ongoingçš„äº‹åŠ¡å¿…é¡»å›æ»š
  4. **åˆ†åŒºåˆ—è¡¨**ï¼šå¿…é¡»è®°å½•æ‰€æœ‰æ¶‰åŠçš„åˆ†åŒº

  ---

  ### éš¾ç‚¹2ï¼šProduceråƒµå°¸å®ä¾‹é—®é¢˜ï¼ˆZombie Fencingï¼‰

  é—®é¢˜åœºæ™¯ï¼š

  ```
  æ—¶åˆ»T1: Producerå®ä¾‹Aå¯åŠ¨
          - producer_id = 123
          - producer_epoch = 0

  æ—¶åˆ»T2: Producer Aå¼€å§‹äº‹åŠ¡txn-1
          - å‘é€æ¶ˆæ¯åˆ°åˆ†åŒº1, 2, 3

  æ—¶åˆ»T3: Producer Aç½‘ç»œåˆ†åŒºï¼ˆå‡æ­»ï¼‰
          - ä½†äº‹åŠ¡è¿˜æ²¡æäº¤
          - Coordinatorè®¤ä¸ºè¶…æ—¶ï¼Œå›æ»štxn-1

  æ—¶åˆ»T4: åº”ç”¨é‡å¯Producer B
          - producer_id = 123ï¼ˆå¤ç”¨ï¼‰
          - producer_epoch = 1ï¼ˆé€’å¢ï¼ï¼‰â­

  æ—¶åˆ»T5: Producer Aç½‘ç»œæ¢å¤ï¼ˆåƒµå°¸ï¼ï¼‰
          - å°è¯•æäº¤txn-1
          - epoch = 0ï¼ˆè¿‡æœŸï¼‰

  é—®é¢˜ï¼šå¦‚æœä¸é˜»æ­¢ï¼ŒProducer Aä¼šç ´åProducer Bçš„äº‹åŠ¡ï¼
  ```

  è§£å†³æ–¹æ¡ˆï¼šEpochæœºåˆ¶ï¼ˆå›´æ /Fencingï¼‰

  ```rust
  struct TransactionalProducer {
      producer_id: i64,
      producer_epoch: i16,  // â­ æ¯æ¬¡é‡å¯é€’å¢
      txn_id: String,
  }

  impl TransactionCoordinator {
      // åˆå§‹åŒ–äº‹åŠ¡æ—¶æ£€æŸ¥epoch
      async fn init_producer_id(&mut self, txn_id: &str) -> Result<(i64, i16)> {
          match self.txn_log.get_producer_info(txn_id).await? {
              Some((producer_id, last_epoch)) => {
                  // å·²å­˜åœ¨ï¼Œé€’å¢epoch
                  let new_epoch = last_epoch + 1;

                  // â­ æŒä¹…åŒ–æ–°epochï¼ˆå¿…é¡»åœ¨è¿”å›ä¹‹å‰ï¼ï¼‰
                  self.txn_log.update_epoch(txn_id, producer_id, new_epoch).await?;

                  // å›æ»šæ—§epochçš„æœªå®Œæˆäº‹åŠ¡
                  self.abort_transactions_with_epoch(producer_id, last_epoch).await?;

                  Ok((producer_id, new_epoch))
              }
              None => {
                  // æ–°producerï¼Œåˆ†é…IDå’Œepoch=0
                  let producer_id = self.allocate_producer_id();
                  self.txn_log.register_producer(txn_id, producer_id, 0).await?;
                  Ok((producer_id, 0))
              }
          }
      }

      // æ‰€æœ‰äº‹åŠ¡æ“ä½œéƒ½æ£€æŸ¥epoch
      async fn begin_transaction(&mut self, req: BeginTxnRequest) -> Result<()> {
          let txn = self.transactions.get(&req.txn_id).ok_or(NotFound)?;

          // â­ å…³é”®æ£€æŸ¥
          if req.producer_epoch < txn.producer_epoch {
              return Err(ProducerFenced {
                  message: format!(
                      "Producer epoch {} < current epoch {}",
                      req.producer_epoch, txn.producer_epoch
                  )
              });
          }

          // ... å…¶ä»–é€»è¾‘
      }
  }

  // Brokerç«¯ä¹Ÿè¦æ£€æŸ¥
  impl Partition {
      async fn append_transactional_record(&mut self, record: Record) -> Result<u64> {
          // æ£€æŸ¥epoch
          if let Some(last_epoch) = self.last_producer_epoch.get(&record.producer_id) {
              if record.producer_epoch < *last_epoch {
                  return Err(InvalidProducerEpoch {
                      message: format!(
                          "Stale epoch {} < {}",
                          record.producer_epoch, last_epoch
                      )
                  });
              }
          }

          // æ›´æ–°epoch
          self.last_producer_epoch.insert(record.producer_id, record.producer_epoch);

          // ... å†™å…¥è®°å½•
      }
  }
  ```

  å…³é”®ç‚¹ï¼š
  1. **Epoché€’å¢**ï¼šæ¯æ¬¡Produceré‡å¯éƒ½é€’å¢
  2. **æŒä¹…åŒ–epoch**ï¼šå¿…é¡»åœ¨è¿”å›å‰æŒä¹…åŒ–ï¼ˆé˜²æ­¢é‡å¤åˆ†é…ï¼‰
  3. **æ‹’ç»æ—§epoch**ï¼šCoordinatorå’ŒBrokeréƒ½è¦æ£€æŸ¥
  4. **è‡ªåŠ¨å›æ»š**ï¼šæ–°epochå¯åŠ¨æ—¶ï¼Œå›æ»šæ—§epochçš„æœªå®Œæˆäº‹åŠ¡

  ---

  ### éš¾ç‚¹3ï¼šLSOï¼ˆLast Stable Offsetï¼‰è®¡ç®—çš„å¤æ‚æ€§

  é—®é¢˜ï¼šå¤šä¸ªäº¤å‰äº‹åŠ¡æ—¶å¦‚ä½•è®¡ç®—LSOï¼Ÿ

  ```
  Partitionçš„æ¶ˆæ¯åºåˆ—ï¼š

  Offset   Message              Transaction   Status
  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  100      [msg-1]              -             committed
  101      [msg-2, txn=A]       A             ongoing   â† txn-Aå¼€å§‹
  102      [msg-3, txn=B]       B             ongoing   â† txn-Bå¼€å§‹
  103      [msg-4, txn=A]       A             ongoing
  104      [msg-5]              -             committed
  105      [msg-6, txn=B]       B             ongoing
  106      [COMMIT, txn=A]      A             committed â† txn-Aç»“æŸ
  107      [msg-7, txn=C]       C             ongoing   â† txn-Cå¼€å§‹
  108      [msg-8]              -             committed
  109      [COMMIT, txn=B]      B             committed â† txn-Bç»“æŸ
  110      [msg-9, txn=C]       C             ongoing

  é—®é¢˜ï¼šLSOåº”è¯¥æ˜¯å¤šå°‘ï¼Ÿ

  é”™è¯¯ç­”æ¡ˆ1ï¼š106ï¼ˆæœ€æ—©çš„COMMITï¼‰
  â†’ ä¸å¯¹ï¼Œtxn-Bè¿˜åœ¨ongoing

  é”™è¯¯ç­”æ¡ˆ2ï¼š109ï¼ˆæœ€åçš„COMMITï¼‰
  â†’ ä¸å¯¹ï¼Œtxn-Cè¿˜åœ¨ongoing

  æ­£ç¡®ç­”æ¡ˆï¼š107 â­
  â†’ å› ä¸ºoffset 107ä¹‹å‰çš„æ‰€æœ‰äº‹åŠ¡éƒ½å·²æäº¤
  â†’ offset 107å¼€å§‹æœ‰æœªæäº¤çš„txn-C
  ```

  å®ç°ï¼š

  ```rust
  struct Partition {
      leo: u64,  // Log End Offset
      hw: u64,   // High Watermark
      lso: u64,  // Last Stable Offset

      // â­ å…³é”®æ•°æ®ç»“æ„ï¼šæŒ‰èµ·å§‹offsetæ’åºçš„æœªå®Œæˆäº‹åŠ¡
      ongoing_txns: BTreeMap<u64, OngoingTransaction>,
  }

  #[derive(Debug, Clone)]
  struct OngoingTransaction {
      txn_id: String,
      producer_id: i64,
      first_offset: u64,  // äº‹åŠ¡çš„ç¬¬ä¸€æ¡æ¶ˆæ¯offset
      last_offset: u64,   // ç›®å‰çš„æœ€åä¸€æ¡æ¶ˆæ¯offset
  }

  impl Partition {
      fn append_txn_message(&mut self, record: TransactionalRecord) -> Result<u64> {
          let offset = self.leo;

          // å†™å…¥æ¶ˆæ¯
          self.log.append(record.clone())?;
          self.leo += 1;

          if record.is_control {
              // æ§åˆ¶æ¶ˆæ¯ï¼ˆCOMMIT/ABORTï¼‰
              self.handle_control_message(record)?;
          } else if record.is_transactional {
              // äº‹åŠ¡æ¶ˆæ¯
              self.ongoing_txns
                  .entry(record.producer_id)
                  .and_modify(|txn| {
                      txn.last_offset = offset;
                  })
                  .or_insert(OngoingTransaction {
                      txn_id: record.txn_id.clone(),
                      producer_id: record.producer_id,
                      first_offset: offset,
                      last_offset: offset,
                  });
          }

          self.update_lso();
          Ok(offset)
      }

      fn handle_control_message(&mut self, record: TransactionalRecord) -> Result<()> {
          match record.control_type {
              ControlType::Commit | ControlType::Abort => {
                  // ç§»é™¤å¯¹åº”çš„ongoing transaction
                  self.ongoing_txns.remove(&record.producer_id);
              }
          }
          Ok(())
      }

      // â­ LSOæ›´æ–°é€»è¾‘
      fn update_lso(&mut self) {
          // LSO = ç¬¬ä¸€ä¸ªæœªå®Œæˆäº‹åŠ¡çš„èµ·å§‹offset
          // å¦‚æœæ²¡æœ‰æœªå®Œæˆäº‹åŠ¡ï¼ŒLSO = HW

          self.lso = self.ongoing_txns
              .values()
              .map(|txn| txn.first_offset)
              .min()  // å–æœ€å°å€¼ï¼
              .unwrap_or(self.hw);
      }

      // Consumerè¯»å–æ—¶ä½¿ç”¨
      fn fetch(&self, offset: u64, isolation_level: IsolationLevel) -> Vec<Record> {
          let max_offset = match isolation_level {
              IsolationLevel::ReadUncommitted => self.hw,
              IsolationLevel::ReadCommitted => self.lso,  // â­
          };

          self.log.read_range(offset, max_offset)
              .into_iter()
              .filter(|r| {
                  // è¿‡æ»¤æ‰æ§åˆ¶æ¶ˆæ¯ï¼ˆæ¶ˆè´¹è€…ä¸åº”è¯¥çœ‹åˆ°ï¼‰
                  !r.is_control
              })
              .collect()
      }
  }
  ```

  å¤æ‚åœºæ™¯ç¤ºä¾‹ï¼š

  ```rust
  #[test]
  fn test_lso_with_interleaved_transactions() {
      let mut partition = Partition::new();

      // offset 0-99: æ™®é€šæ¶ˆæ¯
      for i in 0..100 {
          partition.append(normal_message(i));
      }
      assert_eq!(partition.lso, 100);  // æ— äº‹åŠ¡ï¼ŒLSO = HW

      // offset 100: txn-Aå¼€å§‹
      partition.append(txn_message(100, "txn-A", 123));
      assert_eq!(partition.lso, 100);  // LSOåœåœ¨txn-Aå¼€å§‹çš„åœ°æ–¹

      // offset 101-103: txn-Bäº¤å‰
      partition.append(txn_message(101, "txn-B", 456));
      partition.append(txn_message(102, "txn-A", 123));
      partition.append(txn_message(103, "txn-B", 456));
      assert_eq!(partition.lso, 100);  // è¿˜æ˜¯100ï¼ˆtxn-Aæœ€æ—©ï¼‰

      // offset 104: txn-A COMMIT
      partition.append(control_commit(104, "txn-A", 123));
      assert_eq!(partition.lso, 101);  // â­ LSOå‰è¿›åˆ°txn-B

      // offset 105: æ™®é€šæ¶ˆæ¯
      partition.append(normal_message(105));
      assert_eq!(partition.lso, 101);  // è¿˜æ˜¯å¡åœ¨txn-B

      // offset 106: txn-B COMMIT
      partition.append(control_commit(106, "txn-B", 456));
      assert_eq!(partition.lso, 107);  // â­ LSOè·³åˆ°HWï¼ˆæ— æœªå®Œæˆäº‹åŠ¡ï¼‰
  }
  ```

  å…³é”®ç‚¹ï¼š
  1. **BTreeMapæŒ‰offsetæ’åº**ï¼šå¿«é€Ÿæ‰¾åˆ°æœ€æ—©çš„äº‹åŠ¡
  2. **Control Messageæ›´æ–°LSO**ï¼šæäº¤/å›æ»šæ—¶ç§»é™¤äº‹åŠ¡
  3. **äº¤å‰äº‹åŠ¡å¤„ç†**ï¼šå¤šä¸ªäº‹åŠ¡åŒæ—¶è¿›è¡Œæ—¶ï¼ŒLSOå–æœ€å°å€¼
  4. **æ¶ˆè´¹è€…éš”ç¦»**ï¼šREAD_COMMITTEDåªèƒ½è¯»åˆ°LSOä¹‹å‰

  ---

  ### éš¾ç‚¹4ï¼šè·¨å¤šä¸ªåˆ†åŒºçš„åŸå­æ€§ï¼ˆTwo-Phase Commitçš„å˜ç§ï¼‰

  é—®é¢˜ï¼šå¦‚ä½•ä¿è¯å¤šä¸ªåˆ†åŒºè¦ä¹ˆéƒ½çœ‹åˆ°COMMITï¼Œè¦ä¹ˆéƒ½çœ‹åˆ°ABORTï¼Ÿ

  ```
  åœºæ™¯ï¼šäº‹åŠ¡txn-1å†™å…¥äº†3ä¸ªåˆ†åŒº

  åˆ†åŒºA: [msg1, msg2, COMMIT?]
  åˆ†åŒºB: [msg3, COMMIT?]
  åˆ†åŒºC: [msg4, msg5, msg6, COMMIT?]

  å¦‚æœåœ¨å‘é€COMMITåˆ°åˆ†åŒºBæ—¶ç½‘ç»œæ•…éšœï¼š
  â†’ åˆ†åŒºAå·²æäº¤ï¼ˆæ¶ˆè´¹è€…èƒ½çœ‹åˆ°msg1, msg2ï¼‰
  â†’ åˆ†åŒºB/Cæœªæäº¤ï¼ˆæ¶ˆè´¹è€…çœ‹ä¸åˆ°ï¼‰
  â†’ ä¸ä¸€è‡´ï¼
  ```

  Kafkaçš„è§£å†³æ–¹æ¡ˆï¼š**å…ˆæŒä¹…åŒ–å†³ç­–ï¼Œå†åˆ†å‘**

  ```rust
  impl TransactionCoordinator {
      async fn commit_transaction(&mut self, req: CommitTxnRequest) -> Result<()> {
          let txn = self.transactions.get_mut(&req.txn_id).ok_or(NotFound)?;

          // ===== é˜¶æ®µ1: å‡†å¤‡æäº¤ï¼ˆå†³ç­–ç‚¹ï¼‰=====
          // â­ å…³é”®ï¼šå…ˆæŒä¹…åŒ–"å†³å®šè¦æäº¤"è¿™ä¸ªå†³ç­–
          txn.state = TransactionState::PrepareCommit;
          self.txn_log.write_state_change(&txn).await?;

          // â­ æ­¤æ—¶å³ä½¿å´©æºƒï¼Œæ¢å¤åä¹Ÿä¼šç»§ç»­æäº¤

          // ===== é˜¶æ®µ2: å‘æ‰€æœ‰åˆ†åŒºå‘é€COMMIT =====
          let control_msg = ControlMessage::Commit(txn.txn_id.clone());
          let mut failed_partitions = Vec::new();

          for partition in &txn.partitions {
              match self.send_control_message(partition, control_msg.clone()).await {
                  Ok(_) => {
                      println!("âœ“ Sent COMMIT to {:?}", partition);
                  }
                  Err(e) => {
                      eprintln!("âœ— Failed to send COMMIT to {:?}: {}", partition, e);
                      failed_partitions.push(partition.clone());
                  }
              }
          }

          // â­ å…³é”®ï¼šå³ä½¿éƒ¨åˆ†åˆ†åŒºå¤±è´¥ï¼Œä¹Ÿä¸å›æ»šï¼
          // å› ä¸ºå·²ç»æŒä¹…åŒ–äº†PrepareCommitå†³ç­–

          if !failed_partitions.is_empty() {
              // åå°ä»»åŠ¡ä¼šé‡è¯•è¿™äº›åˆ†åŒº
              self.retry_queue.push(RetryTask {
                  txn_id: txn.txn_id.clone(),
                  partitions: failed_partitions,
                  control_msg,
              });
          }

          // ===== é˜¶æ®µ3: æ ‡è®°å®Œæˆ =====
          // åªæœ‰å½“æ‰€æœ‰åˆ†åŒºéƒ½ç¡®è®¤åæ‰æ ‡è®°CompleteCommit
          if failed_partitions.is_empty() {
              txn.state = TransactionState::CompleteCommit;
              self.txn_log.write_state_change(&txn).await?;

              // æ¸…ç†äº‹åŠ¡æ•°æ®
              self.transactions.remove(&txn.txn_id);
          }

          Ok(())
      }

      // åå°é‡è¯•ä»»åŠ¡
      async fn retry_control_messages(&self) {
          loop {
              tokio::time::sleep(Duration::from_secs(1)).await;

              while let Some(task) = self.retry_queue.pop() {
                  for partition in &task.partitions {
                      match self.send_control_message(partition, task.control_msg.clone()).await {
                          Ok(_) => {
                              println!("âœ“ Retry succeeded for {:?}", partition);
                              // ä»é‡è¯•åˆ—è¡¨ç§»é™¤
                          }
                          Err(e) => {
                              eprintln!("âœ— Retry failed: {}", e);
                              // æ”¾å›é˜Ÿåˆ—ç»§ç»­é‡è¯•
                              self.retry_queue.push_back(task.clone());
                              break;
                          }
                      }
                  }
              }
          }
      }
  }
  ```

  Control Messageçš„å¹‚ç­‰å‘é€ï¼š

  ```rust
  impl Partition {
      async fn append_control_message(&mut self, msg: ControlMessage) -> Result<()> {
          // â­ æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰è¿™ä¸ªäº‹åŠ¡çš„æ§åˆ¶æ¶ˆæ¯
          if let Some(existing) = self.find_control_message(&msg.txn_id) {
              if existing.control_type == msg.control_type {
                  // å¹‚ç­‰ï¼šå·²ç»æœ‰ç›¸åŒçš„æ§åˆ¶æ¶ˆæ¯ï¼Œç›´æ¥è¿”å›æˆåŠŸ
                  println!("Control message already exists, skipping");
                  return Ok(());
              } else {
                  // å†²çªï¼šå·²æœ‰COMMITï¼Œç°åœ¨æ”¶åˆ°ABORTï¼ˆæˆ–ç›¸åï¼‰
                  return Err(ConflictingControlMessage {
                      existing: existing.control_type,
                      new: msg.control_type,
                  });
              }
          }

          // è¿½åŠ æ§åˆ¶æ¶ˆæ¯
          let offset = self.leo;
          self.log.append(ControlRecord {
              offset,
              control_type: msg.control_type,
              txn_id: msg.txn_id.clone(),
              producer_id: msg.producer_id,
          })?;

          self.leo += 1;
          self.update_lso();  // å¯èƒ½ä¼šæ›´æ–°LSO

          Ok(())
      }
  }
  ```

  å…³é”®ç‚¹ï¼š
  1. **PrepareCommitæ˜¯å†³ç­–ç‚¹**ï¼šæŒä¹…åŒ–åä¸å¯å›é€€
  2. **å¹‚ç­‰å‘é€**ï¼šControl Messageå¯ä»¥é‡å¤å‘é€
  3. **å¼‚æ­¥é‡è¯•**ï¼šéƒ¨åˆ†å¤±è´¥ä¸é˜»å¡ï¼Œåå°é‡è¯•
  4. **æœ€ç»ˆä¸€è‡´æ€§**ï¼šæ‰€æœ‰åˆ†åŒºæœ€ç»ˆä¼šæ”¶åˆ°COMMIT

  ---

  ### éš¾ç‚¹5ï¼šConsumerçš„READ_COMMITTEDå®ç°

  é—®é¢˜ï¼šConsumerå¦‚ä½•çŸ¥é“å“ªäº›æ¶ˆæ¯å¯ä»¥è¯»ï¼Ÿ

  ```
  åˆ†åŒºæ—¥å¿—ï¼š

  Offset   Record                 Txn      Status
  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  100      normal-msg-1           -        âœ“
  101      txn-A-msg-1           A        ?  â† äº‹åŠ¡Aå¼€å§‹
  102      txn-A-msg-2           A        ?
  103      normal-msg-2           -        âœ“
  104      txn-B-msg-1           B        ?  â† äº‹åŠ¡Bå¼€å§‹
  105      txn-A-msg-3           A        ?
  106      COMMIT(txn-A)         A        âœ“  â† äº‹åŠ¡Aæäº¤
  107      txn-B-msg-2           B        ?
  108      normal-msg-3           -        âœ“
  109      ABORT(txn-B)          B        âœ—  â† äº‹åŠ¡Bå›æ»š
  110      txn-C-msg-1           C        ?  â† äº‹åŠ¡Cï¼ˆæœªæäº¤ï¼‰

  Consumeråº”è¯¥è¯»åˆ°ä»€ä¹ˆï¼Ÿ
  - READ_UNCOMMITTED: offset 0-109å…¨éƒ¨ï¼ˆä¸è¿‡æ»¤ï¼‰
  - READ_COMMITTED:   offset 0-106 ä¸­çš„ [100, 101-102-105(txn-A), 103, 108]
                      è¿‡æ»¤æ‰ï¼š104, 107, 109(txn-B)
                      åœåœ¨ï¼š110ï¼ˆLSOåœ¨è¿™é‡Œï¼‰
  ```

  å®ç°ï¼š

  ```rust
  struct Consumer {
      isolation_level: IsolationLevel,
      // â­ è·Ÿè¸ªå·²æäº¤/å·²å›æ»šçš„äº‹åŠ¡
      aborted_txns: AbortedTransactionIndex,
  }

  // å­˜å‚¨å·²å›æ»šäº‹åŠ¡çš„ç´¢å¼•
  struct AbortedTransactionIndex {
      // producer_id -> (first_offset, last_offset)
      aborted_ranges: HashMap<i64, Vec<(u64, u64)>>,
  }

  impl Consumer {
      async fn fetch(&mut self, partition: &Partition, offset: u64) -> Result<Vec<Record>> {
          // 1. è·å–å¯è¯»èŒƒå›´
          let max_offset = match self.isolation_level {
              IsolationLevel::ReadUncommitted => partition.hw,
              IsolationLevel::ReadCommitted => partition.lso,
          };

          // 2. è¯»å–åŸå§‹è®°å½•
          let raw_records = partition.log.read_range(offset, max_offset)?;

          // 3. è¿‡æ»¤
          let filtered = raw_records
              .into_iter()
              .filter(|record| {
                  // è¿‡æ»¤æ§åˆ¶æ¶ˆæ¯ï¼ˆConsumerä¸åº”è¯¥çœ‹åˆ°ï¼‰
                  if record.is_control {
                      // ä½†è¦æ›´æ–°aborted_txnsç´¢å¼•
                      if record.control_type == ControlType::Abort {
                          self.aborted_txns.add(record.producer_id, record.first_offset, record.last_offset);
                      }
                      return false;
                  }

                  // â­ READ_COMMITTED: è¿‡æ»¤æ‰å·²å›æ»šäº‹åŠ¡çš„æ¶ˆæ¯
                  if self.isolation_level == IsolationLevel::ReadCommitted {
                      if record.is_transactional {
                          if self.aborted_txns.contains(record.producer_id, record.offset) {
                              return false;  // è¿™æ¡æ¶ˆæ¯å±äºå·²å›æ»šäº‹åŠ¡
                          }
                      }
                  }

                  true
              })
              .collect();

          Ok(filtered)
      }
  }

  impl AbortedTransactionIndex {
      fn add(&mut self, producer_id: i64, first_offset: u64, last_offset: u64) {
          self.aborted_ranges
              .entry(producer_id)
              .or_insert_with(Vec::new)
              .push((first_offset, last_offset));
      }

      fn contains(&self, producer_id: i64, offset: u64) -> bool {
          if let Some(ranges) = self.aborted_ranges.get(&producer_id) {
              ranges.iter().any(|(first, last)| {
                  offset >= *first && offset <= *last
              })
          } else {
              false
          }
      }

      // æ¸…ç†æ—§çš„èŒƒå›´ï¼ˆoffsetå·²ç»æ¶ˆè´¹è¿‡äº†ï¼‰
      fn gc(&mut self, min_offset: u64) {
          for ranges in self.aborted_ranges.values_mut() {
              ranges.retain(|(_, last)| *last >= min_offset);
          }
          self.aborted_ranges.retain(|_, ranges| !ranges.is_empty());
      }
  }
  ```

  ä¼˜åŒ–ï¼šBrokerç«¯æä¾›Aborted Transactions

  ```rust
  // Brokeråœ¨Fetch Responseä¸­è¿”å›å·²å›æ»šäº‹åŠ¡çš„åˆ—è¡¨
  struct FetchResponse {
      records: Vec<Record>,

      // â­ Kafka 0.11.0+ æ–°å¢å­—æ®µ
      aborted_transactions: Vec<AbortedTransaction>,
  }

  struct AbortedTransaction {
      producer_id: i64,
      first_offset: u64,
  }

  impl Partition {
      fn fetch_with_aborted_txns(
          &self,
          offset: u64,
          isolation_level: IsolationLevel
      ) -> FetchResponse {
          let max_offset = match isolation_level {
              IsolationLevel::ReadUncommitted => self.hw,
              IsolationLevel::ReadCommitted => self.lso,
          };

          let records = self.log.read_range(offset, max_offset);

          // â­ æ”¶é›†å·²å›æ»šäº‹åŠ¡
          let aborted_txns = self.log
              .scan_range(offset, max_offset)
              .filter_map(|record| {
                  if record.is_control && record.control_type == ControlType::Abort {
                      Some(AbortedTransaction {
                          producer_id: record.producer_id,
                          first_offset: record.first_offset,
                      })
                  } else {
                      None
                  }
              })
              .collect();

          FetchResponse {
              records,
              aborted_transactions: aborted_txns,
          }
      }
  }
  ```

  å…³é”®ç‚¹ï¼š
  1. **LSOé™åˆ¶è¯»å–èŒƒå›´**ï¼šREAD_COMMITTEDä¸èƒ½è¶…è¿‡LSO
  2. **è¿‡æ»¤å·²å›æ»šæ¶ˆæ¯**ï¼šé€šè¿‡AbortedTransactionIndexåˆ¤æ–­
  3. **æ§åˆ¶æ¶ˆæ¯ä¸å¯è§**ï¼šConsumeræ°¸è¿œçœ‹ä¸åˆ°COMMIT/ABORTè®°å½•
  4. **Brokerä¼˜åŒ–**ï¼šæä¾›aborted_transactionså‡å°‘Consumerè´Ÿæ‹…

  ---

  ### éš¾ç‚¹6ï¼šæ€§èƒ½ä¼˜åŒ– vs æ­£ç¡®æ€§çš„æƒè¡¡

  æ ¸å¿ƒçŸ›ç›¾ï¼šäº‹åŠ¡ä¿è¯æ­£ç¡®æ€§ï¼Œä½†ç‰ºç‰²æ€§èƒ½

  æ€§èƒ½ç“¶é¢ˆç‚¹ï¼š

  1. **äº‹åŠ¡æ—¥å¿—åŒæ­¥å†™å…¥**
  ```rust
  // æ…¢ä½†å®‰å…¨
  async fn begin_transaction(&mut self, txn_id: &str) -> Result<()> {
      self.txn_log.write(txn_id, TransactionState::Ongoing).await?;  // fsync!
      self.transactions.insert(txn_id, ...);
      Ok(())
  }

  // å¿«ä½†å±é™©
  async fn begin_transaction_unsafe(&mut self, txn_id: &str) -> Result<()> {
      self.transactions.insert(txn_id, ...);  // ä»…å†…å­˜
      self.txn_log.write_async(txn_id, TransactionState::Ongoing);  // åå°å†™
      // é—®é¢˜ï¼šå´©æºƒåäº‹åŠ¡ä¸¢å¤±ï¼
  }
  ```

  2. **Control Messageçš„å†™å…¥**
  ```rust
  // æ–¹æ¡ˆAï¼šåŒæ­¥ç­‰å¾…æ‰€æœ‰åˆ†åŒºç¡®è®¤ï¼ˆæ…¢ä½†å®‰å…¨ï¼‰
  async fn commit_transaction(&mut self, txn: &Transaction) -> Result<()> {
      for partition in &txn.partitions {
          self.send_control_message(partition, COMMIT).await?;  // ç­‰å¾…ACK
      }
      // å…¨éƒ¨ç¡®è®¤åæ‰è¿”å›
  }

  // æ–¹æ¡ˆBï¼šå¼‚æ­¥å‘é€ï¼ˆå¿«ä½†å¤æ‚ï¼‰
  async fn commit_transaction_async(&mut self, txn: &Transaction) -> Result<()> {
      let futures: Vec<_> = txn.partitions
          .iter()
          .map(|p| self.send_control_message(p, COMMIT))
          .collect();

      tokio::spawn(async move {
          join_all(futures).await;  // åå°ç­‰å¾…
      });

      // ç«‹å³è¿”å›ï¼ˆä½†äº‹åŠ¡å¯èƒ½æœªå®Œæˆï¼ï¼‰
  }
  ```

  3. **LSOæ›´æ–°çš„ä»£ä»·**
  ```rust
  // æ¯æ¬¡appendéƒ½æ›´æ–°LSOï¼ˆç²¾ç¡®ä½†æ…¢ï¼‰
  fn append(&mut self, record: Record) -> Result<u64> {
      let offset = self.write_to_log(record)?;
      self.update_lso();  // â† æ¯æ¬¡éƒ½éå†ongoing_txns
      Ok(offset)
  }

  // æ‰¹é‡æ›´æ–°LSOï¼ˆå¿«ä½†å¯èƒ½å»¶è¿Ÿï¼‰
  fn append_batch(&mut self, records: Vec<Record>) -> Result<Vec<u64>> {
      let offsets = records.iter()
          .map(|r| self.write_to_log(r))
          .collect::<Result<Vec<_>>>()?;

      self.update_lso();  // â† åªæ›´æ–°ä¸€æ¬¡
      Ok(offsets)
  }
  ```

  Kafkaçš„é€‰æ‹©ï¼š**å¯é…ç½®çš„å®‰å…¨çº§åˆ«**

  ```rust
  #[derive(Debug, Clone)]
  enum TransactionDurability {
      // 0: æœ€å¿«ï¼Œæœ€ä¸å®‰å…¨ï¼ˆä»…æµ‹è¯•ç”¨ï¼‰
      NoSync,

      // 1: å¹³è¡¡ï¼ˆé»˜è®¤ï¼‰
      // - äº‹åŠ¡æ—¥å¿—å¼‚æ­¥åˆ·ç›˜
      // - Control MessageåŒæ­¥ç­‰å¾…Leaderç¡®è®¤
      LeaderAck,

      // 2: æœ€å®‰å…¨ï¼Œæœ€æ…¢
      // - æ‰€æœ‰å†™å…¥åŒæ­¥fsync
      // - Control Messageç­‰å¾…æ‰€æœ‰å‰¯æœ¬ç¡®è®¤
      FullSync,
  }

  struct TransactionConfig {
      durability: TransactionDurability,

      // äº‹åŠ¡è¶…æ—¶ï¼ˆè¶…è¿‡æ­¤æ—¶é—´æœªæäº¤è‡ªåŠ¨å›æ»šï¼‰
      timeout_ms: u64,  // é»˜è®¤60ç§’

      // æ˜¯å¦å…è®¸å¹¶å‘äº‹åŠ¡ï¼ˆå½±å“LSOè®¡ç®—å¤æ‚åº¦ï¼‰
      allow_concurrent: bool,
  }
  ```

  ---

  ### éš¾ç‚¹7ï¼šä¸å‰¯æœ¬æœºåˆ¶çš„äº¤äº’

  é—®é¢˜ï¼šäº‹åŠ¡æ¶ˆæ¯å¦‚ä½•å¤åˆ¶åˆ°Followerï¼Ÿ

  ```
  åœºæ™¯ï¼š
  1. Leaderæ”¶åˆ°äº‹åŠ¡æ¶ˆæ¯
  2. å¤åˆ¶åˆ°Follower
  3. å¦‚æœLeaderåœ¨å‘é€COMMITå‰å´©æºƒï¼Œæ–°Leaderæ€ä¹ˆåŠï¼Ÿ

  Leaderå®•æœºå‰ï¼š
  Leader:   [msg1, msg2, msg3]  (txn-A, uncommitted)
  Follower: [msg1, msg2]        (å¤åˆ¶å»¶è¿Ÿ)

  æ–°Leaderé€‰ä¸¾åï¼š
  New Leader: [msg1, msg2]      â† msg3ä¸¢å¤±äº†ï¼
  Old Leader: [msg1, msg2, msg3] â† æ¢å¤åæˆä¸ºFollower

  é—®é¢˜ï¼šmsg3è¿˜è¦å—ï¼Ÿtxn-Aåº”è¯¥æäº¤è¿˜æ˜¯å›æ»šï¼Ÿ
  ```

  è§£å†³æ–¹æ¡ˆï¼šLeader Epoch + æˆªæ–­

  ```rust
  struct ReplicaManager {
      leader_epoch: u64,
  }

  impl ReplicaManager {
      // æˆä¸ºLeaderæ—¶
      async fn become_leader(&mut self) -> Result<()> {
          self.leader_epoch += 1;

          // â­ å›æ»šæ‰€æœ‰æœªå®Œæˆçš„äº‹åŠ¡
          for txn in self.partition.ongoing_txns.values() {
              self.abort_transaction(txn.txn_id).await?;
          }

          // å‘æ‰€æœ‰Followerå¹¿æ’­æ–°epoch
          self.broadcast_leader_epoch(self.leader_epoch).await?;

          Ok(())
      }

      // Followeræ”¶åˆ°æ–°Leaderçš„epoch
      async fn on_leader_epoch_change(&mut self, new_epoch: u64) -> Result<()> {
          if new_epoch > self.leader_epoch {
              // â­ æˆªæ–­æ—¥å¿—åˆ°æœ€åä¸€ä¸ªCOMMIT/ABORT
              let last_stable_offset = self.find_last_committed_offset();
              self.partition.truncate(last_stable_offset).await?;

              self.leader_epoch = new_epoch;
          }
          Ok(())
      }
  }
  ```

  å…³é”®ç‚¹ï¼š
  1. **Leaderå˜æ›´å›æ»šäº‹åŠ¡**ï¼šæ–°Leaderä¸Šä»»æ—¶å›æ»šæ‰€æœ‰æœªå®Œæˆäº‹åŠ¡
  2. **Followeræˆªæ–­æ—¥å¿—**ï¼šä¸¢å¼ƒæœªæäº¤çš„äº‹åŠ¡æ¶ˆæ¯
  3. **Epochæœºåˆ¶**ï¼šé˜²æ­¢æ—§Leaderå›æ¥åç ´åæ•°æ®

  ---

  ## å®ç°éš¾åº¦æ€»ç»“

  ### æœ€éš¾çš„5ä¸ªé—®é¢˜

  1. **Coordinatorå´©æºƒæ¢å¤** (éš¾åº¦: 10/10)
     - å¿…é¡»ä¿è¯PrepareCommitåä¸€å®šå®Œæˆæäº¤
     - æ¢å¤æ—¶é‡æ–°å‘é€Control Message
     - å¹‚ç­‰æ€§å¤„ç†

  2. **Zombie Fencing** (éš¾åº¦: 9/10)
     - Epochæœºåˆ¶è®¾è®¡
     - æ‰€æœ‰è·¯å¾„éƒ½è¦æ£€æŸ¥epoch
     - ä¸ç½‘ç»œåˆ†åŒºçš„äº¤äº’

  3. **è·¨åˆ†åŒºåŸå­æ€§** (éš¾åº¦: 9/10)
     - éƒ¨åˆ†åˆ†åŒºå¤±è´¥çš„å¤„ç†
     - é‡è¯•æœºåˆ¶
     - æœ€ç»ˆä¸€è‡´æ€§ä¿è¯

  4. **LSOè®¡ç®—** (éš¾åº¦: 8/10)
     - äº¤å‰äº‹åŠ¡çš„å¤„ç†
     - æ€§èƒ½ä¼˜åŒ–
     - æ­£ç¡®æ€§éªŒè¯

  5. **ä¸å‰¯æœ¬æœºåˆ¶äº¤äº’** (éš¾åº¦: 9/10)
     - Leaderåˆ‡æ¢æ—¶çš„äº‹åŠ¡çŠ¶æ€
     - æ—¥å¿—æˆªæ–­
     - Epochç®¡ç†

  ### ä¼°ç®—å·¥ä½œé‡

  å‡è®¾å•äººå…¨èŒå¼€å‘ï¼š

  ```
  æ¨¡å—                        æ—¶é—´          å¤æ‚åº¦
  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  1. åŸºç¡€æ¡†æ¶                 1å‘¨          â˜…â˜…
     - TransactionCoordinator
     - TransactionState
     - åŸºæœ¬API

  2. Transaction Log          2å‘¨          â˜…â˜…â˜…â˜…
     - æŒä¹…åŒ–
     - æ¢å¤æœºåˆ¶
     - æ€§èƒ½ä¼˜åŒ–

  3. Producerå¹‚ç­‰æ€§           1å‘¨          â˜…â˜…â˜…
     - producer_idåˆ†é…
     - sequenceç®¡ç†

  4. Epochæœºåˆ¶               2å‘¨          â˜…â˜…â˜…â˜…â˜…
     - Zombie fencing
     - å„å¤„æ£€æŸ¥ç‚¹

  5. Control Message         2å‘¨          â˜…â˜…â˜…â˜…
     - è·¨åˆ†åŒºå‘é€
     - å¹‚ç­‰å¤„ç†
     - é‡è¯•æœºåˆ¶

  6. LSOå®ç°                 2å‘¨          â˜…â˜…â˜…â˜…
     - æ•°æ®ç»“æ„
     - æ›´æ–°é€»è¾‘
     - æ€§èƒ½ä¼˜åŒ–

  7. Consumeræ”¯æŒ            1å‘¨          â˜…â˜…â˜…
     - READ_COMMITTED
     - è¿‡æ»¤å·²å›æ»šæ¶ˆæ¯

  8. ä¸å‰¯æœ¬é›†æˆ              3å‘¨          â˜…â˜…â˜…â˜…â˜…
     - Leaderåˆ‡æ¢
     - æ—¥å¿—æˆªæ–­
     - ä¸€è‡´æ€§ä¿è¯

  9. æµ‹è¯•                    4å‘¨          â˜…â˜…â˜…â˜…â˜…
     - å•å…ƒæµ‹è¯•
     - é›†æˆæµ‹è¯•
     - æ··æ²Œæµ‹è¯•
     - æ€§èƒ½æµ‹è¯•

  æ€»è®¡ï¼šçº¦18å‘¨ï¼ˆ4.5ä¸ªæœˆï¼‰
  ```

  ### ä¸ºä»€ä¹ˆä¸å»ºè®®ä»é›¶å®ç°ï¼Ÿ

  1. **æ”¶ç›Šæœ‰é™**ï¼šå¤§å¤šæ•°åœºæ™¯ä¸éœ€è¦å®Œæ•´äº‹åŠ¡
  2. **é£é™©é«˜**ï¼šä¸€ä¸ªbugå°±å¯èƒ½å¯¼è‡´æ•°æ®ä¸¢å¤±
  3. **ç»´æŠ¤æˆæœ¬**ï¼šéœ€è¦æŒç»­æµ‹è¯•å’Œä¼˜åŒ–
  4. **æ›¿ä»£æ–¹æ¡ˆ**ï¼šå¹‚ç­‰æ€§ + æœ¬åœ°æ¶ˆæ¯è¡¨èƒ½è§£å†³80%é—®é¢˜

  ---
  æ ¸å¿ƒè§‚ç‚¹ï¼šåˆ†å¸ƒå¼äº‹åŠ¡æ˜¯é«˜çº§ç‰¹æ€§ï¼Œä¸æ˜¯æ ¸å¿ƒåŠŸèƒ½ã€‚å¯¹äºMQæ¥è¯´ï¼Œå‰¯æœ¬ä¸€è‡´æ€§è¿œæ¯”äº‹åŠ¡é‡è¦ï¼